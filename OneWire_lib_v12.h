// Библиотека для работы с интерфейсом 1-Wire и цифровым термометром BS18B20
// v1.2.0_2012-07-28
// Аппаратная платформа: отладочная плата EasyPIC 6
// Зависимости: функции Delay_us(), Delay_ms() среды microC PRO for PIC
// Автор: Егор Змушко, А.В. Цурко (Ratgor)
// Рефакторинг: А.В. Цурко (Ratgor)



/*
// Настройки подключения датчика к порту
#define DS_TRIS TRISA    // 8-битный регистр направлений порта А
#define DS_PORT PORTA    // 8-битный регистр значений порта А
#define DS 5             // Номер используемой ножки порта
*/



// Прототипы функций:

// Функции мастера
void          OneWire_Byte_Tx (unsigned char);    // Передача одного байта
unsigned char OneWire_Byte_Rx (void);             // Прием одного байта
unsigned char OneWire_Reset   (void);             // Сброс устройств на линии
unsigned char OneWire_Match_ROM_Tx                // Передача данных (массива байт) по ROM(ASCII)
(unsigned char *, unsigned char *, unsigned char);

// Работа стермодатчиками DS18B20
unsigned char DS_ConvT          (void);           // Преобразование температуры для всех датчиков на линии
unsigned char DS_Read           (void);           // Чтение температуры в массив ASCII
unsigned char DS_Read_ROM       (void);           // Чтение уникального ROM идентификатора в массив ASCII
unsigned char DS_Match_ROM      (unsigned char*); // Чтение температуры по ROM(ASCII) в массив ASCII
double        DS_ReadTemp_byROM (unsigned char*); // Чтение температуры в число с плавающей точкой


// Функции слэйва
unsigned char OneWire_Slave_Presence  (void);                  // Подтверждение присутсвия на линии (выполняется слэйвом)
unsigned char OneWire_Slave_Byte_Rx   (void);                  // Приема одного байта (выполняется слэйвом)
void          OneWire_Slave_Byte_Tx   (unsigned char);         // Передача одного байта (выполняется слейвом)
void          OneWire_Slave_Read_ROM  (unsigned char *ROM);    // Функция передаёт ROM-номер (выполняется слэйвом)
unsigned char OneWire_Slave_Match_ROM (unsigned char *ROM);    // Функция опознаёт ROM-номер (выполняется слэйвом)



// Функция отправки одного байта по интерфейсу 1-Wire
void OneWire_Byte_Tx (unsigned char whu){

    // Переменная-счетчик количества переданных бит
    unsigned char i;

    // Цикл побитной передачи байта, начиная с младшего бита
    for(i=0;i<8;i++){

        // Передача каждого бита осуществляется в тайм слоте (ТС)
        // (Это отрезок времени длительностью 60-120 мкс + 1 мкс пауза меду ТС)
        // Каждый ТС начинается занулением линии (1-15 мкс)
        // Каждый бит определяется состоянием линии через некоторое время
        // после начала тайм слота. Передача бита = 0 отличается большим
        // временем удержания линии в низком состоянии, чем передача бита = 1

        // Если передаваемый бит = 1
        if(whu &(1<<i)){
            // Настраиваем линию на выход
            DS_TRIS &= ~(1<<DS);
            // Прижимаем линию к земле выводом на линию логического нуля
            DS_PORT &= ~(1<<DS);
            // Держим ее около 2 мкс(для передачи единицы)
            Delay_us(2);
            // Отпускаем линию, переводя ее на вход
            DS_TRIS |= (1<<DS);
            // Время для завершения тайм слота
            Delay_us(93);
        }
        // Если передаваемый бит = 0
        else{
            // Настраиваем линию на выход
            DS_TRIS &= ~(1<<DS);
            // Прижимаем линию к земле выводом на линию логического нуля
            DS_PORT &= ~(1<<DS);
            // При передаче нуля время прижатия линии к земле больше
            Delay_us(83);
            DS_TRIS |= (1<<DS);
            Delay_us(12);
        }
    }
    // После каждого переданного байта нужно выдержать некоторую паузу
    // Что бы это не делать в основной программе, ожидание будет здесь
    Delay_us(500);

}



// Функция приема одного байта
unsigned char OneWire_Byte_Rx (void){

    // Переменные: принятый байт и счетчик количества принятых бит
    unsigned char temp=0, i;

    // Цикл побитного приема байта, начиная с младшего бита
    for(i=0;i<8;i++){

        // Передача каждого бита осуществляется в тайм слоте (ТС)
        // (Это отрезок времени длительностью 60-120 мкс + 1 мкс пауза меду ТС)
        // Каждый ТС начинается занулением линии (1-15 мкс)
        // Каждый бит определяется состоянием линии через некоторое время
        // после начала тайм слота. Передача бита = 0 обозначается занулением
        // линии ведомым устройством, передача бита = 1 - отсутствием зануления

        // Формируем ТС для приема:
        DS_TRIS &= ~(1<<DS);
        DS_PORT &= ~(1<<DS);
        // Выдерживаем зануление начала ТС (здесь 1 мкс)
        Delay_us(1);
        // и отпускаем линию.
        DS_TRIS |= (1<<DS);
        // Ждем начала ответа ведомого устройства (здесь 13 мкс)
        Delay_us(13);
        // и читаем данные.

        // Логическое состояние линии прямо соответствует передаваемому биту.
        // Передача начинается с младшего байта и младшего бита.

        // Если = 1, то устанавливаем в приемный регистр сдвига старшим битом 1
        if(DS_PORT & (1<<DS)){
            temp |= 128;
        }
        // Если = 0,то так и оставляем в старшем бите 0
        else{
            //temp >>= 1;
        }
        // Если принимаем не последний бит, то сдвигаем влево приемный регистр сдвига
        if(i<7)
            temp>>=1;
        // Согласно документации делаем паузу и повторяем
        Delay_us(100);
    }
    // Согласно документации к ведомому устройству, выдерживаем паузу
    Delay_us(500);

    // По окончании приема 8 бит, возвращаем сформированный байт
    return temp;
}



// Функция формирования импульса сброса на линии
unsigned char OneWire_Reset (void){

    // Начало работы с любым устройством предваряется командой сброса линии
    // Для сброса ведущее устройство зануляет линию на время 480 мкс
    // После сброса линии ведомое устройство обозначает свое присутствие на линии
    // Для обозначения присутствия после отпускания линии ведущим устройством,
    // линию зануляет ведомое устройство (электронный термометр - на 60-240 мкс)

    // Для сброса прижимаем линию к земле на время не менее 480 мкс
    DS_TRIS &= ~(1<<DS);
    DS_PORT &= ~(1<<DS);
    Delay_us(500);
    DS_TRIS |= (1<<DS);
    // После сброса, если есть устройство на линии, принимаем ответ
    Delay_us(40);
    // Если уровень линии = 0, то устройство есть, в противном случае его нет.
    // Если устройства нет на линии, возвращаем 1
    if(DS_PORT&(1<<DS)){
        Delay_us(500);
        return 1;
    }
    // При наличии устройства на линии, возвращаем 0
    Delay_us(500);
    return 0;
}



// Функция считывает показания датчика, преобразовывает числа в ASCII символы,
// помещает их в массив и возвращает указатель на этот массив
unsigned char *DS_Read(void){

    // Переменные для старшего и младшего байт значения измеренной температуры
    unsigned char tempH, tempL;
    // Переменные для ASCII символов, соответствующих измеренной температуре
    // Значение 0x30 соответствует началу цифр "0,1,2,3..." в ASCII таблице
    unsigned char znak=0, doDot=0, posleDot=0, d100=0x30, d10=0x30, d1=0x30, p1000=0x30, p100=0x30, p10=0x30, p1=0x30;
    // Переменная для преобразования дробной части значения измеренной температуры
    int pDec=0;
    // Массив в котором хранятся данные для вывода на индикатор
    static unsigned char DispTemp[10];

    // Команды:
    // Сброс термодатчика (ресет всех устройств на линии)
    // Пропуск ROM (номер термодатчика) (у нас только одно устройство на линии)
    // Начать преобразование температуры (всем устройствам на линии)
    if(OneWire_Reset()){
        DispTemp[0] = 'N';
        DispTemp[1] = 'o';
        DispTemp[2] = ' ';
        DispTemp[3] = 'S';
        DispTemp[4] = 'e';
        DispTemp[5] = 'n';
        DispTemp[6] = 's';
        DispTemp[7] = 'o';
        DispTemp[8] = 'r';
        DispTemp[9] = '\0';
        return &DispTemp;
    }
    OneWire_Byte_Tx (0xCC);
    OneWire_Byte_Tx (0x44);

    // Ждем некоторое время. Время преобразования температуры от 100 до 750 мс.
    Delay_ms(750);

    // Команды:
    // Сброс термодатчика (ресет всех устройств на линии). Если устройств нет, выдаем ошибку.
    // Пропуск ROM (номер термодатчика) (у нас только одно устройство на линии)
    // Начать чтение памяти с показаниями температуры (всем устройствам на линии)
    if(OneWire_Reset()){
        DispTemp[0] = 'N';
        DispTemp[1] = 'o';
        DispTemp[2] = ' ';
        DispTemp[3] = 'S';
        DispTemp[4] = 'e';
        DispTemp[5] = 'n';
        DispTemp[6] = 's';
        DispTemp[7] = 'o';
        DispTemp[8] = 'r';
        DispTemp[9] = '\0';
        return &DispTemp;
    }
    OneWire_Byte_Tx (0xCC);
    OneWire_Byte_Tx (0xBE);

    // Чтение двух байт значения измеренной температуры
    // Знак измеренной температуры находится в старшем байте (старшие 5 бит)
    // Целочисленное значение температуры находится в старшем и младшем байтах
    // Дробное значение температуры находится в младшем байте (младшие 4 бита)

    // Младший байт значения измеренной температуры
    tempL = OneWire_Byte_Rx ();
    // Старший значения измеренной температуры
    tempH = OneWire_Byte_Rx ();

    // Определяем знак температуры (5 старших бит в старшем байте)
    // Если = 1 то отрицательная температура
    if(tempH & 128)
        znak = 0x2D;  // Код знака "-"  в ASCII
    // Если 0 - то положительная
    else
        znak = 0x2B;   // Код знака "+"  в ASCII

    // Поместим целую и дробную части значения измеренной температуры
    // в отдельные переменные
    posleDot = (tempL & 0x0F);  // Cохраняем дробную часть в переменной
    doDot |= (tempL>>4);        // Сохраняем младшие 4 бита целой части
    doDot |= ((tempH&0x07)<<4); // Сохраняем старшие 4 бита целой части

    // Разбиваем полученные значения на разряды сотен десятков и единиц
    // и переводим в соответствующие ASCII символы

    // Подсчитаем сколько сотен градусов (сразу в ASCII)
    while(doDot>=100){
        doDot-=100;
        d100++;
    }
    // Подсчитаем сколько десятков градусов (сразу в ASCII)
    while(doDot>=10){
        doDot-=10;
        d10++;
    }
    // Подсчитаем сколько единиц градусов (сразу в ASCII)
    while(doDot>=1){
        doDot-=1;
        d1++;
    }

    // Преобразовываем дробную часть через целочисленную переменную
    // используем тип int вместо double
    // умножим все данные на 1000, чтобы самое маленькое число (0,0625) стало целым

    // Третий разряд дробной части соответствует 0,5
    if(posleDot&8)
        pDec = 5000;

    // Второй разряд дробной части соответствует 0,25
    if(posleDot&4)
        pDec += 2500;

    // Первый разряд дробной части соответствует 0,125
    if(posleDot&2)
        pDec += 1250;

    // Нулевой разряд дробной соответствует 0,0625
    if(posleDot&1)
        pDec += 625;

    // Вычисляем чему равен каждый разряд (сразу в ASCII)

    // Десятые доли градуса
    while(pDec>=1000){
        pDec -= 1000;
        p1000++;
    }
    // Сотые доли градуса
    while(pDec>=100){
        pDec -= 100;
        p100++;
    }
    // Тысячные доли градуса
    while(pDec>=10){
        pDec -= 10;
        p10++;
    }
    // Десятитысячные доли градуса
    while(pDec>=1){
        pDec -= 1;
        p1++;
    }

    // Так как при поразрядном вычислении значения измеренной температуры
    // мы прибавляли количественные значения в разрядах к числу 0x30,
    // то мы сразу получили значение цифр в ASCII коде.

    // Заносим их в массив
    DispTemp[0] = znak;    // Знак
    DispTemp[1] = d100;    // Целая часть, сотни
    DispTemp[2] = d10;     // Целая часть, десятки
    DispTemp[3] = d1;      // Целая часть, единицы
    DispTemp[4] = '.';     // Десятичная точка
    DispTemp[5] = p1000;   // Дробная часть, десятки
    DispTemp[6] = p100;    // Дробная часть, сотни
    DispTemp[7] = p10;     // Дробная часть, тысячи
    DispTemp[8] = p1;      // Дробная часть, десятки тысяч
    DispTemp[9] = '\0';    // Конец текстового массива

    // Возвращаем указатель на массив
    return &DispTemp;
}




// Функция дает команду преобразования температуры всем устройствам на линии
unsigned char *DS_ConvT(void){

    // Массив в котором хранятся данные для вывода на индикатор
    static unsigned char DispTemp[10];

    // Команды:
    // Сброс термодатчика (ресет всех устройств на линии)
    // Пропуск ROM (номер термодатчика) (у нас только одно устройство на линии)
    // Начать преобразование температуры (всем устройствам на линии)
    if(OneWire_Reset()){
        DispTemp[0] = 'N';
        DispTemp[1] = 'o';
        DispTemp[2] = ' ';
        DispTemp[3] = 'S';
        DispTemp[4] = 'e';
        DispTemp[5] = 'n';
        DispTemp[6] = 's';
        DispTemp[7] = 'o';
        DispTemp[8] = 'r';
        DispTemp[9] = '\0';
        return &DispTemp;
    }
    OneWire_Byte_Tx (0xCC);
    OneWire_Byte_Tx (0x44);

    // Ждем некоторое время. Время преобразования температуры от 100 до 750 мс.
    Delay_ms(750);

    DispTemp[0] = 'C';
    DispTemp[1] = 'o';
    DispTemp[2] = 'n';
    DispTemp[3] = 'v';
    DispTemp[4] = 'R';
    DispTemp[5] = 'e';
    DispTemp[6] = 'a';
    DispTemp[7] = 'd';
    DispTemp[8] = 'y';
    DispTemp[9] = '\0';
        
        return &DispTemp;
}



// Функция считывает уникальный ROM идентификатор датчика (8 байт),
// преобразовывает числа в ASCII символы,
// помещает их в массив и возвращает указатель на этот массив
unsigned char *DS_Read_ROM(void){

    // Переменная-счетчик для номеров байт в ROM-номере
    unsigned char ROM_Counter=8;
    // Буффер для хранения полубайт из ROM-номера
    unsigned char ROM_Buffer;
    // Массив в котором хранятся данные для вывода на индикатор
    static unsigned char DispTemp[17];

    // Команды:

    // Сброс термодатчика (ресет всех устройств на линии)
    if(OneWire_Reset()){
        DispTemp[0] = 'N';
        DispTemp[1] = 'o';
        DispTemp[2] = ' ';
        DispTemp[3] = 'D';
        DispTemp[4] = 'e';
        DispTemp[5] = 'v';
        DispTemp[6] = 'i';
        DispTemp[7] = 'c';
        DispTemp[8] = 'e';
        DispTemp[9] = '\0';
        return &DispTemp;
    }

    // Начать передачу ROM (для всех устройств на линии)
    OneWire_Byte_Tx (0x33);

    // Записать принимаемый ROM (8 байт) в массив ASCII символов
    while(ROM_Counter--){
        ROM_Buffer = OneWire_Byte_Rx();
        if((ROM_Buffer/16)<0x0A)
            DispTemp[ROM_Counter*2] = ROM_Buffer/16 + 0x30;
        else
            DispTemp[ROM_Counter*2] = ROM_Buffer/16 + 0x37;
        if((ROM_Buffer%16)<0x0A)
            DispTemp[ROM_Counter*2+1] = ROM_Buffer%16 + 0x30;
        else
            DispTemp[ROM_Counter*2+1] = ROM_Buffer%16 + 0x37;
    }
    DispTemp[16] = '\0';

    // Возвращаем указатель на массив
    return &DispTemp;
}



// Функция считывает показания датчика, преобразовывает числа в ASCII символы,
// помещает их в массив и возвращает указатель на этот массив
// Датчик выбирается по уникальному ROM идентификачтору, записанному в массив ASCII символов
unsigned char *DS_Match_ROM(unsigned char *ROM){

    // Переменные для старшего и младшего байт значения измеренной температуры
    unsigned char tempH, tempL;
    // Переменная-счетчик для номеров байт в ROM-номере
    unsigned char ROM_Counter=8;
    // Буффер для хранения пбайт в ROM-номере
    unsigned char ROM_Buffer;
    // Переменные для ASCII символов, соответствующих измеренной температуре
    // Значение 0x30 соответствует началу цифр "0,1,2,3..." в ASCII таблице
    unsigned char znak=0, doDot=0, posleDot=0, d100=0x30, d10=0x30, d1=0x30, p1000=0x30, p100=0x30, p10=0x30, p1=0x30;
    // Переменная для преобразования дробной части значения измеренной температуры
    int pDec=0;
    // Массив в котором хранятся данные для вывода на индикатор
    static unsigned char DispTemp[10];

    // Ждем некоторое время. Время преобразования температуры от 100 до 750 мс.
    Delay_ms(750);

    // Команды:
    // Сброс термодатчика (ресет всех устройств на линии). Если устройств нет, выдаем ошибку.
    if(OneWire_Reset()){
        DispTemp[0] = 'N';
        DispTemp[1] = 'o';
        DispTemp[2] = ' ';
        DispTemp[3] = 'S';
        DispTemp[4] = 'e';
        DispTemp[5] = 'n';
        DispTemp[6] = 's';
        DispTemp[7] = 'o';
        DispTemp[8] = 'r';
        DispTemp[9] = '\0';
        return DispTemp;
    }

    // Выбор устройства на линии по точному совпадению ROM (номер термодатчика)
    OneWire_Byte_Tx (0x55);

    // Начать передачу ROM для выбора соответствующего устройства на линии
    while(ROM_Counter--) {
        if(ROM[ROM_Counter*2]>0x39) {
            ROM_Buffer = (ROM[ROM_Counter*2] - 0x37)*16;
        } else {
            ROM_Buffer = (ROM[ROM_Counter*2] - 0x30)*16;
        }
        if(ROM[ROM_Counter*2+1]>0x39) {
            ROM_Buffer += (ROM[ROM_Counter*2+1] - 0x37);
        } else {
            ROM_Buffer += (ROM[ROM_Counter*2+1] - 0x30);
        }
        OneWire_Byte_Tx(ROM_Buffer);
    }
    // Начать чтение памяти с показаниями температуры (всем устройствам на линии)
        OneWire_Byte_Tx (0xBE);

    // Чтение двух байт значения измеренной температуры
    // Знак измеренной температуры находится в старшем байте (старшие 5 бит)
    // Целочисленное значение температуры находится в старшем и младшем байтах
    // Дробное значение температуры находится в младшем байте (младшие 4 бита)

    // Младший байт значения измеренной температуры
    tempL = OneWire_Byte_Rx ();
    // Старший значения измеренной температуры
    tempH = OneWire_Byte_Rx ();

    // Проверка наличия на линии требуемого датчика
     if((tempL==0xFF)&&(tempH==0xFF)){
        DispTemp[0] = 'N';
        DispTemp[1] = 'o';
        DispTemp[2] = ' ';
        DispTemp[3] = 'S';
        DispTemp[4] = 'e';
        DispTemp[5] = 'n';
        DispTemp[6] = 's';
        DispTemp[7] = 'o';
        DispTemp[8] = 'r';
        DispTemp[9] = '\0';
        return DispTemp;
    }

    // Определяем знак температуры (5 старших бит в старшем байте)
    // Если = 1 то отрицательная температура
    if(tempH & 128)
        znak = 0x2D;  // Код знака "-"  в ASCII
    // Если 0 - то положительная
    else
        znak = 0x2B;   // Код знака "+"  в ASCII

    // Поместим целую и дробную части значения измеренной температуры
    // в отдельные переменные
    posleDot = (tempL & 0x0F);  // Cохраняем дробную часть в переменной
    doDot |= (tempL>>4);        // Сохраняем младшие 4 бита целой части
    doDot |= ((tempH&0x07)<<4); // Сохраняем старшие 4 бита целой части

    // Разбиваем полученные значения на разряды сотен десятков и единиц
    // и переводим в соответствующие ASCII символы

    // Подсчитаем сколько сотен градусов (сразу в ASCII)
    while(doDot>=100){
        doDot-=100;
        d100++;
    }
    // Подсчитаем сколько десятков градусов (сразу в ASCII)
    while(doDot>=10){
        doDot-=10;
        d10++;
    }
    // Подсчитаем сколько единиц градусов (сразу в ASCII)
    while(doDot>=1){
        doDot-=1;
        d1++;
    }

    // Преобразовываем дробную часть через целочисленную переменную
    // используем тип int вместо double
    // умножим все данные на 1000, чтобы самое маленькое число (0,0625) стало целым

    // Третий разряд дробной части соответствует 0,5
    if(posleDot&8)
        pDec = 5000;

    // Второй разряд дробной части соответствует 0,25
    if(posleDot&4)
        pDec += 2500;

    // Первый разряд дробной части соответствует 0,125
    if(posleDot&2)
        pDec += 1250;

    // Нулевой разряд дробной соответствует 0,0625
    if(posleDot&1)
        pDec += 625;

    // Вычисляем чему равен каждый разряд (сразу в ASCII)

    // Десятые доли градуса
    while(pDec>=1000){
        pDec -= 1000;
        p1000++;
    }
    // Сотые доли градуса
    while(pDec>=100){
        pDec -= 100;
        p100++;
    }
    // Тысячные доли градуса
    while(pDec>=10){
        pDec -= 10;
        p10++;
    }
    // Десятитысячные доли градуса
    while(pDec>=1){
        pDec -= 1;
        p1++;
    }

    // Так как при поразрядном вычислении значения измеренной температуры
    // мы прибавляли количественные значения в разрядах к числу 0x30,
    // то мы сразу получили значение цифр в ASCII коде.

    // Заносим их в массив
    DispTemp[0] = znak;    // Знак
    DispTemp[1] = d100;    // Целая часть, сотни
    DispTemp[2] = d10;     // Целая часть, десятки
    DispTemp[3] = d1;      // Целая часть, единицы
    DispTemp[4] = '.';     // Десятичная точка
    DispTemp[5] = p1000;   // Дробная часть, десятки
    DispTemp[6] = p100;    // Дробная часть, сотни
    DispTemp[7] = p10;     // Дробная часть, тысячи
    DispTemp[8] = p1;      // Дробная часть, десятки тысяч
    DispTemp[9] = '\0';    // Конец текстового массива

    // Возвращаем указатель на массив
    return DispTemp;
}


//##############################################################################
//
// Ниже располагаются функции, добавленные с 12 версии библиотеки, а именно:
// Термодатчик - получить температуру в double
// Мастер - выбрать устройство по ROM и передать данные
// Слэйв - подтверждение присутсвия, прием одного байта, передача одного байта,
// Слэйв - Match_ROM (сравнить свой ROM с принятым), Read_ROM (передать свой ROM)
//
//##############################################################################



// Функция считывает показания датчика, преобразовывает число с плавающей точкой
// Датчик выбирается по уникальному ROM идентификачтору, записанному в массив ASCII символов
double DS_ReadTemp_byROM(unsigned char *ROM){

    // представление измеренной температуры с плавающей запятой
    double temp_buffer = 0.;
    // Переменные для старшего и младшего байт значения измеренной температуры
    unsigned char tempH, tempL;
    // Переменная-счетчик для номеров байт в ROM-номере
    unsigned char ROM_Counter=8;
    // Буффер для хранения пбайт в ROM-номере
    unsigned char ROM_Buffer;

    // Команды:
    // Сброс термодатчика (ресет всех устройств на линии). Если устройств нет, выдаем ошибку.
    if(OneWire_Reset())
        return -666.;

    // Выбор устройства на линии по точному совпадению ROM (номер термодатчика)
    OneWire_Byte_Tx (0x55);

    // Начать передачу ROM для выбора соответствующего устройства на линии
    while(ROM_Counter--) {
        if(ROM[ROM_Counter*2]>0x39) {
            ROM_Buffer = (ROM[ROM_Counter*2] - 0x37)*16;
        } else {
            ROM_Buffer = (ROM[ROM_Counter*2] - 0x30)*16;
        }
        if(ROM[ROM_Counter*2+1]>0x39) {
            ROM_Buffer += (ROM[ROM_Counter*2+1] - 0x37);
        } else {
            ROM_Buffer += (ROM[ROM_Counter*2+1] - 0x30);
        }
        OneWire_Byte_Tx(ROM_Buffer);
    }
    // Начать чтение памяти с показаниями температуры (всем устройствам на линии)
        OneWire_Byte_Tx (0xBE);

    // Чтение двух байт значения измеренной температуры
    // Знак измеренной температуры находится в старшем байте (старшие 5 бит)
    // Целочисленное значение температуры находится в старшем и младшем байтах
    // Дробное значение температуры находится в младшем байте (младшие 4 бита)

    // Младший байт значения измеренной температуры
    tempL = OneWire_Byte_Rx ();
    // Старший значения измеренной температуры
    tempH = OneWire_Byte_Rx ();

    // Проверка наличия на линии требуемого датчика
     if((tempL==0xFF)&&(tempH==0xFF)){
        return 666.;
    }

    // Определяем знак температуры (5 старших бит в старшем байте)
    // Если = 1 то отрицательная температура
    if(tempH & 128)
        temp_buffer = -0.;
    // Если 0 - то положительная
    else
        temp_buffer = +0.;

    // Переводим значение в число с плавающей запятой
    temp_buffer += (((tempH & 0x07)<<4) + ((tempL & 0xF0) >>4));
    if(tempL & 0x01)     temp_buffer += 0.5;
    if(tempL & 0x02)     temp_buffer += 0.25;
    if(tempL & 0x04)     temp_buffer += 0.125;
    if(tempL & 0x08)     temp_buffer += 0.0625;

    // Возвращаем указатель на массив
    return temp_buffer;
}



// Функция передаёт n байт данных (LSB) устройству  на линии,
// заданному по ROM в ASCII
// Возвращает 1 если нет устройства, иначе 0
unsigned char OneWire_Match_ROM_Tx(unsigned char *ROM, unsigned char *dat, unsigned char n){

    // Хранение значений отдельных байт ROM-номера и передаваемых данных
    unsigned char buffer;
    // Счетчик для номеров отдельных байт в ROM-номере и массиве данных
    unsigned char counter=8;

    // Ресет (Сброс всех устройств на линии)
    // Если устройств нет, выдаем ошибку возвращая 1
    if(OneWire_Reset())
        return 1;

    // Команда выбора устройства на линии по точному совпадению ROM-номера
    OneWire_Byte_Tx (0x55);

    // Передача ROM с конца (преобразуем младшую пару символов)
    while(Counter--) {

        // Старший ASCII символ
        if(ROM[Counter*2]>0x39)
            Buffer = (ROM[Counter*2] - 0x37) * 16; // A..F
        else
            Buffer = (ROM[Counter*2] - 0x30) * 16; // 0..9

        //Младший ASCII символ
        if(ROM[Counter*2+1]>0x39)
            Buffer += (ROM[Counter*2+1] - 0x37); // A..F
        else
            Buffer += (ROM[Counter*2+1] - 0x30); // 0..9

        // Передача сформированного байта
        OneWire_Byte_Tx(Buffer);
    }

    // Передачу данных с конца (младшего, последнего байта в массиве)
    counter = n;
    while(counter--) {
        Buffer = dat[counter];
        OneWire_Byte_Tx(Buffer);
    }
    // Если передача прошла успешно, возвращаем 0
    return 0;
}


// 3.1 OneWire_Slave_Presence
// Формирование импульса подтверждения присутствия на линии (выполняется слэйвом)
// Возвращает 1 если присутствие подтверждено, иначе 0
unsigned char OneWire_Slave_Presence(void){

    // Начало работы с любым устройством предваряется командой сброса линии
    // Для сброса ведущее устройство зануляет линию на время 480 мкс
    // После сброса линии ведомое устройство обозначает свое присутствие на линии
    // Для обозначения присутствия после отпускания линии ведущим устройством,
    // линию зануляет ведомое устройство (электронный термометр - на 60-240 мкс)

    // Счетчик длительности любого заземления
    unsigned char counter = 1;
    // Временная разметка ресета с подтвержедием.
    // Замеренная для DS18B20: '0'-502 мкс, '1'-30 мкс, '0'-114 мкс.
    // Используемая в нашем слачая: '0'-502 мкс, '1'-30 мкс, '0'-102 мкс.
    // Если счетчик инициализировать 0, то ничего не работает (?!)
    // Если разница счетчика и порога (по умолчанию они 1 и 45) меньше 13
    // подверждение прсутствия начинает срабатывать на "нулевые" таймслоты мастера
    // Кажется, длительности '0' таймслота мастера по счетчику 10 единиц, а по измерениям 85 мкс
    // Тогда длительность ресета 502/85=59 по счетчику (с delay_us(1); и PORTC = counter;)

    // Назначаем линию как Вход
    DS_TRIS |= (1<<DS);
    //Если обнаружен низкий уровень, считаем длительность заземления линии
    while(!(DS_PORT&(1<<DS))){
        if(counter>60)
            counter=60;
        else
            counter++;
        delay_us(1);
    }
    // Если замеренная длительность слишком мала для ресета, возвращаем 0
     if(counter < 45)     //counter<143 - works, counnter<144 - don't work (без паузы)
        return counter;//0;

    // Иначе подтверждаем присутствие на линии
    // Немного подождем, чтобы остальные слэйвы тоже услышали конец ресета (не обязательно)
    Delay_us(20);

    // Назначем линию как Выход и Заземляем
    DS_TRIS &= ~(1<<DS);
    DS_PORT &= ~(1<<DS);
    // Выдерживаем длительность подтверждения присутствия
    // и освобождаем линию (назначаем как Вход)
    Delay_us(100);
    DS_TRIS |= (1<<DS);
    
    // Ожидаем, пока все слэйвы не отпустят линию
    while(!(DS_PORT|=(1<<DS)));
    
    // После проведённого подтверждения присутствия на линии возвращаем 1
    return 0;//1;

}


// 3.2 OneWire_Slave_Byte_Rx
// Прием одного байта (выполняется слэйвом)
unsigned char OneWire_Slave_Byte_Rx (void){

    // Переменные: принятый байт и счетчик количества принятых бит
    unsigned char temp=0, i;

    // Цикл побитного приема байта, начиная с младшего бита
    for(i=0;i<8;i++){

        // Передача каждого бита осуществляется в тайм слоте (ТС)
        // (Это отрезок времени длительностью 60-120 мкс + 1 мкс пауза меду ТС)
        // Каждый ТС начинается занулением линии (1-15 мкс)
        // Каждый бит определяется состоянием линии через некоторое время
        // после начала тайм слота. Передача бита = 0 обозначается занулением
        // линии ведомым устройством, передача бита = 1 - отсутствием зануления

        // Настраиваем линию как вход
        DS_TRIS |= (1<<DS);
        // Ожидаем начала зануления
        while(DS_PORT&(1<<DS)){};
        // Пропускаем зануление начала ТС (здесь 30 мкс) и установку данных
        Delay_us(30);

        // Читаем бит данных
        // Если = 1, то устанавливаем в приемный регистр сдвига старшим битом 1
        // Если = 0, то так и оставляем в старшем бите 0, и ожидаем конца зануления
        if(DS_PORT & (1<<DS))
            temp |= 128;
        else
            while(!(DS_PORT&(1<<DS))){};

        // Если принимаем не последний бит,
        // то сдвигаем приемный регистр освобождая место следующему биту
        if(i<7)
            temp>>=1;
    }
    // По окончании приема 8 бит, возвращаем сформированный байт
    return temp;
}



// 3.3 OneWire_Slave_Byte_Tx
// Передача одного байта (выполняется слейвом)
void OneWire_Slave_Byte_Tx (unsigned char dat){

    // Счетчик количества переданных бит
    unsigned char i;

    // Цикл побитной передачи байта, начиная с младшего бита
    for(i=0;i<8;i++){

        // Передача каждого бита осуществляется в тайм слоте (ТС)
        // (Это отрезок времени длительностью 60-120 мкс + 1 мкс пауза меду ТС)
        // Каждый ТС начинается занулением линии (1-15 мкс)
        // Каждый бит определяется состоянием линии через некоторое время
        // после начала тайм слота. Передача бита = 0 отличается большим
        // временем удержания линии в низком состоянии, чем передача бита = 1

        // Настраиваем линию как вход
        DS_TRIS |= (1<<DS);

        // Если передаваемый бит = 1
        if(dat &(1<<i)){
            // Ожидаем начала зануления
            while(DS_PORT&(1<<DS));
            // Пропускаем зануление начала ТС (здесь 30 мкс)
            // и ждем автоматическую установку единицы (восстановление напряжения)
            // Ожидаем конца зануления
            while(!(DS_PORT&(1<<DS)));
        }
        // Если передаваемый бит = 0
        else{
            // Ожидаем начала зануления
            while(DS_PORT&(1<<DS));
            // Настраиваем линию на Выход и Заземляем выводом логического нуля
            DS_TRIS &= ~(1<<DS);
            DS_PORT &= ~(1<<DS);
            // При передаче нуля линия прижимается к земле слэйвом
            // (здесь на 30 мкс), а потом отпускается
            Delay_us(60); // Следует ставить задержку <=78 иначе всё плохо
            DS_TRIS |= (1<<DS);
            // Некоторое время на восстановления напряжения на линии (здесь 30 мкс)
            // Ожидаем конца зануления
            while(!(DS_PORT&(1<<DS)));
        }
    }
}



// 3.4 OneWire_Slave_Read_ROM
// Функция передачи ROM-номера (выполняется слэйвом)
// Вызывается когда слэйвом после ресета принята команда Read_ROM (0x33)
void OneWire_Slave_Read_ROM (unsigned char *ROM){

    // Счетчик для номеров одиночных байт в ROM-номере
    unsigned char ROM_Counter=8;
    // Буффер для значений одиночных байт ROM-номера
    unsigned char ROM_Buffer;

    // Передача ROM с конца (преобразуем младшую пару символов)
    while(ROM_Counter--) {

        // Старший ASCII символ
        if(ROM[ROM_Counter*2]>0x39)
            ROM_Buffer = (ROM[ROM_Counter*2] - 0x37) * 16; // A..F
        else
            ROM_Buffer = (ROM[ROM_Counter*2] - 0x30) * 16; // 0..9

        //Младший ASCII символ
        if(ROM[ROM_Counter*2+1]>0x39)
            ROM_Buffer += (ROM[ROM_Counter*2+1] - 0x37); // A..F
        else
            ROM_Buffer += (ROM[ROM_Counter*2+1] - 0x30); // 0..9

        // Передача сформированного байта
        OneWire_Slave_Byte_Tx(ROM_Buffer);
    }
}


// 3.5 OneWire_Slave_Match_ROM
// Функция опознания ROM-номера (выполняется слэйвом)
// Вызывается когда слэйвом после ресета принята команда Match_ROM(0x55)
// Если принятый ROM совпадает с заданным, возвращает 1, слэйв ликует
// Иначе возвращает 0, слэйв тоскует до следующего ресета линии
unsigned char OneWire_Slave_Match_ROM (unsigned char *ROM){

    // Счетчик для номеров одиночных байт в ROM-номере
    unsigned char ROM_Counter=8;
    // Буффер для значений одиночных байт ROM-номера
    unsigned char ROM_Buffer;

    // Проверка ROM с конца (преобразуем младшую пару символов)
    while(ROM_Counter--) {
    
        // Старший ASCII символ
        if(ROM[ROM_Counter*2]>0x39)
            ROM_Buffer = (ROM[ROM_Counter*2] - 0x37) * 16; // A..F
        else
            ROM_Buffer = (ROM[ROM_Counter*2] - 0x30) * 16; // 0..9
        
        //Младший ASCII символ
        if(ROM[ROM_Counter*2+1]>0x39)
            ROM_Buffer += (ROM[ROM_Counter*2+1] - 0x37); // A..F
        else
            ROM_Buffer += (ROM[ROM_Counter*2+1] - 0x30); // 0..9

        // Если значение принятого байта ROM не совпадает с заданным,
        // прерываем процесс приёма, возвращаем 0
        if(OneWire_Slave_Byte_Rx()!=ROM_Buffer)
            return 0;
    }
    // Если значение принятого ROM совпало с заданным, возвращаем 1
    return 1;
}